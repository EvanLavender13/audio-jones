# Code Review Report

**Scope**: `src/` (full codebase review)
**Conventions Reference**: `CLAUDE.md`

## Summary

The codebase matches the documented architecture (audio capture → analysis → render + UI) and generally adheres to the project’s C-style C++ conventions (init/uninit pairs, POD configs with defaults, minimal STL outside `preset.cpp`). The highest-impact issues are concentrated in GPU/resource-lifetime edge cases: the HDR render-texture fallback path appears to discard the depth handle (likely leaking on resize/unload), post-effect init failure paths leak partially loaded shaders, and physarum buffer reallocation failures can leave the simulation in an invalid state (buffer 0 bound).

## Findings

### Major: HDR fallback drops depth handle (likely leaks on resize/unload)

**Location**: `src/render/post_effect.cpp:9` (`InitRenderTextureHDR`)
**Category**: Resource

When HDR FBO creation fails, `InitRenderTextureHDR()` falls back to `LoadRenderTexture()`, but then unconditionally sets `tex->depth.id = 0`. If the fallback render texture has a depth attachment, this drops the handle needed for correct cleanup and can leak GPU resources (especially visible on repeated `PostEffectResize()` calls).

**Evidence**:
```cpp
if (!rlFramebufferComplete(tex->id)) {
    rlUnloadFramebuffer(tex->id);
    rlUnloadTexture(tex->texture.id);
    *tex = LoadRenderTexture(width, height);
}
...
tex->depth.id = 0;
```

**Recommendation**:
- Only clear `depth.id` on the HDR path (where no depth attachment is created). If falling back, preserve `LoadRenderTexture()`’s `depth.id` (or explicitly create a color-only fallback and deterministically manage depth).

---

### Major: PostEffect init failure paths leak partially loaded shader resources

**Location**: `src/render/post_effect.cpp:196` (`PostEffectInit`)
**Category**: Resource

`LoadPostEffectShaders()` can partially succeed (some shaders loaded) while still returning false. `PostEffectInit()` then `free(pe)` without unloading any already-loaded shaders. Similarly, the render-texture failure path unloads only a subset of shaders before freeing the struct. These are GPU leaks in error paths and make init harder to maintain.

**Evidence**:
```cpp
if (!LoadPostEffectShaders(pe)) {
    TraceLog(LOG_ERROR, "POST_EFFECT: Failed to load shaders");
    free(pe);
    return NULL;
}
...
if (pe->accumTexture.id == 0 || pe->tempTexture.id == 0) {
    UnloadShader(pe->blurHShader);
    UnloadShader(pe->blurVShader);
    UnloadShader(pe->chromaticShader);
    free(pe);
    return NULL;
}
```

**Recommendation**:
- Use a single cleanup path (e.g., `goto fail`) that unloads any successfully created shaders/textures before freeing, or refactor to a NULL/0-safe “partial uninit” helper.

---

### Major: Physarum SSBO realloc failure leaves invalid state (buffer 0) and update binds it

**Location**: `src/render/physarum.cpp:445` (`PhysarumApplyConfig`), `src/render/physarum.cpp:286` (`PhysarumUpdate`)
**Category**: Resource | Logic

On agent-buffer reallocation, `PhysarumApplyConfig()` unloads the old SSBO before allocating the replacement. If CPU allocation fails, it sets `p->agentBuffer = 0` and returns. `PhysarumUpdate()` later binds `p->agentBuffer` without guarding for 0, which can cause GL errors and leave the simulation unrecoverable.

**Evidence**:
```cpp
rlUnloadShaderBuffer(p->agentBuffer);
...
if (agents == NULL) {
    p->agentBuffer = 0;
    return;
}
...
rlBindShaderBuffer(p->agentBuffer, 0);
```

**Recommendation**:
- Keep the previous buffer alive until the new one is created (don’t update `agentCount`/`agentBuffer` until success).
- Treat `rlLoadShaderBuffer(...) == 0` as a failure and restore/retain the prior state.
- Add guards in `PhysarumUpdate()`/`PhysarumReset()` to early-return (or disable `config.enabled`) when `agentBuffer == 0`.

---

### Major: Physarum resize continues after trail-map allocation failure (potential invalid render-texture use)

**Location**: `src/render/physarum.cpp:389` (`PhysarumResize`)
**Category**: Resource | Error Handling

`PhysarumResize()` attempts to recreate trail maps, logs errors on failure, then unconditionally calls `PhysarumReset()`. `PhysarumReset()` clears trail maps via `BeginTextureMode(*trailMap)`. If `CreateTrailMap()` failed and left the render textures with `id = 0`, subsequent calls may operate on invalid render textures.

**Evidence**:
```cpp
if (!CreateTrailMap(&p->trailMap, width, height)) {
    TraceLog(LOG_ERROR, "PHYSARUM: Failed to recreate trail map after resize");
}
...
PhysarumReset(p);
```

**Recommendation**:
- Only call `PhysarumReset()` if both trail maps were recreated successfully, or make `ClearTrailMap()`/`PhysarumReset()` robust to `id == 0` (early-return).

---

### Minor: `SpectrumBarsProcess()` dereferences `config` without guarding for NULL

**Location**: `src/render/spectrum_bars.cpp:71` (`SpectrumBarsProcess`)
**Category**: Logic | API Safety

`SpectrumBarsProcess()` checks `sb` and `magnitude`, but reads `config->minDb/maxDb/smoothing` without checking `config`. Other API entry points in the same module guard `config == NULL`.

**Evidence**:
```cpp
if (sb == NULL || magnitude == NULL) { return; }
...
float dbRange = config->maxDb - config->minDb;
```

**Recommendation**:
- Add `config == NULL` to the early-return guard, or document/enforce a non-null precondition consistently in the header.

---

### Minor: Convention violation (missing braces on single-statement `if`)

**Location**: `src/main.cpp:77` (`AppContextInit`)
**Category**: Convention

`CLAUDE.md` specifies braces on all control flow. `AppContextInit()` contains a single-statement `if` without braces.

**Evidence**:
```cpp
if (ctx == NULL) return NULL;
```

**Recommendation**:
- Add braces to match the project rule.

---

### Minor: Unused constant and dead helper

**Location**: `src/analysis/bands.cpp:10`, `src/render/post_effect.cpp:47`
**Category**: Maintainability

`MIN_DENOM` is declared but unused, and `InitRenderTexture()` is defined but unused. These add noise and can mislead future refactors.

**Recommendation**:
- Remove unused constants/helpers or wire them into the intended usage.

## Observations

- The subsystem boundaries and main loop match `docs/architecture.md` closely; audio thread ↔ main thread handoff via ring buffer is clear.
- Using hop-time (`FFT_HOP_SIZE / AUDIO_SAMPLE_RATE`) for beat/band timing keeps analysis behavior consistent across frame rates.
- UI dropdown deferral (`DrawDeferredDropdown`) + global “disable behind open dropdown” pattern is consistently applied across panels.

