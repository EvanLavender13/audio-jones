# Code Review Report

**Scope**: `src/` (full codebase review)
**Conventions Reference**: `CLAUDE.md`

## Summary

Overall structure matches the documented architecture (audio capture → analysis → render + UI), and most code follows the project’s C-style C++ conventions (init/uninit pairs, public config structs, minimal STL in headers). The most impactful issues are in GPU/resource lifetime edge cases: the HDR render-texture fallback path appears to drop the depth handle (likely leaking on resize/unload), and the physarum SSBO reallocation path can leave the simulation in an unrecoverable/broken state after allocation failure. There are also a few minor API-safety and convention-consistency issues.

## Findings

### Major: HDR fallback drops depth handle (likely leaks on resize/unload)

**Location**: `src/render/post_effect.cpp:30`
**Category**: Resource

When HDR FBO creation fails, `InitRenderTextureHDR()` falls back to `LoadRenderTexture()`, but then unconditionally sets `tex->depth.id = 0`. If the fallback render texture includes a depth attachment, this loses the handle needed for correct cleanup and can leak GPU resources (especially visible on repeated `PostEffectResize()` calls).

**Evidence**:
```cpp
if (!rlFramebufferComplete(tex->id)) {
    rlUnloadFramebuffer(tex->id);
    rlUnloadTexture(tex->texture.id);
    *tex = LoadRenderTexture(width, height);
}
...
tex->depth.id = 0;
```

**Recommendation**:
- Only zero `tex->depth.id` when the HDR path actually created no depth attachment; on the fallback path preserve `depth.id` (or explicitly create a color-only fallback and free any depth resource deterministically).

---

### Major: Physarum SSBO realloc failure leaves invalid state (binds buffer 0, weak recovery)

**Location**: `src/render/physarum.cpp:236`
**Category**: Resource | Logic

On agent-buffer reallocation failure, `PhysarumApplyConfig()` sets `p->agentBuffer = 0` and returns. `PhysarumUpdate()` later binds `p->agentBuffer` without guarding for `0`, which can cause GL errors or crashes. Additionally, once `agentBuffer` is zeroed, config-only changes (e.g., color) can trigger `PhysarumReset()`/`rlUpdateShaderBuffer()` using buffer 0.

**Evidence**:
```cpp
PhysarumAgent* agents = (PhysarumAgent*)malloc(p->agentCount * sizeof(PhysarumAgent));
if (agents == NULL) {
    p->agentBuffer = 0;
    return;
}
...
rlBindShaderBuffer(p->agentBuffer, 0);
```

**Recommendation**:
- Keep the previous buffer alive if realloc fails (don’t overwrite `agentCount`/`agentBuffer` until the new buffer is created).
- Treat `rlLoadShaderBuffer(...) == 0` as a failure and keep/restore the prior buffer.
- Add a guard in `PhysarumUpdate()`/`PhysarumReset()` to early-return (or disable `config.enabled`) when `agentBuffer == 0`.

---

### Minor: `PostEffectInit()` failure cleanup leaks partially loaded resources

**Location**: `src/render/post_effect.cpp:150`
**Category**: Resource

`PostEffectInit()` frees `pe` on failure without unloading already-loaded shaders, and the render-texture failure path unloads only a subset of shaders. This leaks GPU resources in error cases and makes the init path harder to maintain.

**Evidence**:
```cpp
if (pe->feedbackShader.id == 0 || pe->blurHShader.id == 0 || ...) {
    TraceLog(LOG_ERROR, "POST_EFFECT: Failed to load shaders");
    free(pe);
    return NULL;
}
...
if (pe->accumTexture.id == 0 || pe->tempTexture.id == 0) {
    UnloadShader(pe->blurHShader);
    UnloadShader(pe->blurVShader);
    UnloadShader(pe->chromaticShader);
    free(pe);
    return NULL;
}
```

**Recommendation**:
- Use a single cleanup path (e.g., `goto fail`) that unloads any successfully created shader/texture before `free(pe)`, or refactor to call a safe “partial uninit” helper that checks handles before unloading.

---

### Minor: `SpectrumBarsProcess()` dereferences `config` without guarding for NULL

**Location**: `src/render/spectrum_bars.cpp:71`
**Category**: Logic

`SpectrumBarsProcess()` checks `sb` and `magnitude`, but uses `config->minDb`, `config->maxDb`, and `config->smoothing` without checking `config`. Other spectrum functions (`SpectrumBarsDraw*`) explicitly guard `config == NULL`.

**Evidence**:
```cpp
if (sb == NULL || magnitude == NULL) {
    return;
}
float dbRange = config->maxDb - config->minDb;
```

**Recommendation**:
- Add `config == NULL` to the early-return guard, or document/enforce a non-null precondition in the header (and keep checks consistent across the module).

---

### Minor: Formatting convention violation (missing braces on single-statement `if`)

**Location**: `src/main.cpp:77`
**Category**: Convention

`CLAUDE.md` specifies braces on all control flow. `AppContextInit()` contains a single-statement `if` without braces.

**Evidence**:
```cpp
if (ctx == NULL) return NULL;
```

**Recommendation**:
- Add braces to match the project rule.

---

### Note: Sample-rate/FFT-size assumptions duplicated as constants across modules

**Location**: `src/analysis/bands.h:6`, `src/analysis/beat.cpp:7`, `src/render/spectrum_bars.cpp:6`
**Category**: Logic | Maintainability

Multiple modules embed bin ranges and frequency mappings assuming 48kHz and 2048 FFT. The project currently uses those values, but if `AUDIO_SAMPLE_RATE` or `FFT_SIZE` changes, these constants become incorrect without a compiler-visible linkage.

**Recommendation**:
- Centralize bin↔frequency helpers derived from `AUDIO_SAMPLE_RATE` and `FFT_SIZE`, or compute bin ranges at init-time from those constants.

---

### Note: Band-energy averaging ignores `dt` and includes unused constant

**Location**: `src/analysis/bands.cpp:5`
**Category**: Logic | Maintainability

The running average update uses fixed coefficients annotated as “~1 second time constant at 60Hz” and does not incorporate `dt`; `MIN_DENOM` is also declared but unused. This makes behavior frame-rate dependent and suggests leftover/dead code.

**Recommendation**:
- Either incorporate `dt` into the averaging (exponential smoothing based on time constant) or document that it assumes a fixed update rate; remove unused constants.

## Observations

- The init/uninit pairing and “init-in-place” pattern is generally consistent (`FFTProcessorInit/Uninit`, `AnalysisPipelineInit/Uninit`, `PostEffectInit/Uninit`).
- Threading model matches the architecture doc: audio callback writes to `ma_pcm_rb`, main thread drains via `AudioCaptureRead()` and processes FFT/beat per frame.
- `src/config/preset.cpp` uses STL/`nlohmann::json` as an explicitly documented deviation; the rest of the codebase largely avoids STL in headers.

